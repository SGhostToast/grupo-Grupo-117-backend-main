openapi: '3.0.2'
info:
  title: Uno Online
  version: '1.0'
servers:
  - url: https://localhost:3000
basePath: /
paths:
  /users/:
    get:
      description: Display the list of the users in the database
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
        '400':
          description: Bad Request
  
  /users/signup:
    post:
      description: Creates a user
      parameters:
      - in: query
        name: username
        required: true
        schema: 
          type: string
      - in: query
        name: password
        required: true
        schema: 
          type: string
      - in: query
        name: mail
        required: true
        schema: 
          type: string
          pattern: '^[a-zA-Z0-9._\\-!¡?¿$&@]+$'
          example: 'user@example.com'
          description: 'Invalid mail format. Must contain only letters, numbers, periods, underscores, hyphens, exclamation marks, question marks, dollar signs, ampersands, and at symbols.'
      responses:
        '201':
          description: The user has been created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '400':
          description: The user could not be created


  /users/login:
    post:
      description: Logs in as user
      parameters:
      - in: query
        name: username
        schema: 
          type: string
      - in: query
        name: mail
        schema: 
          type: string
      - in: query
        name: password
        required: true
        schema: 
          type: string
        schema: 
          anyOf:
            - username
            - mail
      responses:
        '200':
          description: Your are logged as user !
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '400':
          description: Either the username/mail does not exist or the password does not correspond.



# router.post("users.showfriends", "/showfriends", async(ctx) => {
#   try {
#     // This stays like this for now, but when we have multiple sessions and a remote server,
#     // the user id would be retrieved automatically.
#     if(ctx.request.body.username) {
#       const user = await ctx.orm.User.findOne({where:{username:ctx.request.body.username}});
#       if (user) {
#         const friend = await ctx.orm.Friend.findAll({
#           where: {
#             [Op.or]: [
#               {frienderid: user.id, status: 'FRENS'},
#               {befriendedid: user.id, status: 'FRENS'}
#             ]
#           }
#         });
#         ctx.body = {
#           msg: `Lista de amistades.`,
#           friends: friend
#         };
#         ctx.status = 201;
#       }
#       else {
#         throw Error(`No se encontró tu usuario con username ${ctx.request.body.username}.`)
#       }
#     }
#     else {
#       throw Error('Se necesita entregar tu nombre de usuario como "username".')
#     }
#   } catch(error) {
#     ctx.body = { errorMessage: error.message, errorCode: error.code };
#     ctx.status = 400;
#   }
# })

# router.post("users.pendingfriends", "/pendingfriends", async(ctx) => {
#   try {
#     // This stays like this for now, but when we have multiple sessions and a remote server,
#     // the user id would be retrieved automatically.
#     if(ctx.request.body.username) {
#       const user = await ctx.orm.User.findOne({where:{username:ctx.request.body.username}});
#       if (user) {
#         const pending_invites = await ctx.orm.Friend.findAll({where:{befriendedid:user.id, status:'PENDING'}});
#         ctx.body = {
#           msg: `Lista de amistades por aceptar/rechazar encontrada.`,
#           pending_invites: pending_invites
#         };
#         ctx.status = 201;
#       }
#       else {
#         throw Error(`No se encontró tu usuario con username ${ctx.request.body.username}.`)
#       }
#     }
#     else {
#       throw Error('Se necesita entregar tu nombre de usuario como "username".')
#     }
#   } catch(error) {
#     ctx.body = { errorMessage: error.message, errorCode: error.code };
#     ctx.status = 400;
#   }
# })

# router.post("users.pendingrequests", "/pendingrequests", async(ctx) => {
#   try {
#     // This stays like this for now, but when we have multiple sessions and a remote server,
#     // the user id would be retrieved automatically.
#     if(ctx.request.body.username) {
#       const user = await ctx.orm.User.findOne({where:{username:ctx.request.body.username}});
#       if (user) {
#         const pending_requests = await ctx.orm.Friend.findAll({where:{frienderid:user.id, status:'PENDING'}});
#         ctx.body = {
#           msg: `Lista de solicitudes amistades pendientes enviadas.`,
#           pending_requests: pending_requests
#         };
#         ctx.status = 201;
#       }
#       else {
#         throw Error(`No se encontró tu usuario con username ${ctx.request.body.username}.`)
#       }
#     }
#     else {
#       throw Error('Se necesita entregar tu nombre de usuario como "username".')
#     }
#   } catch(error) {
#     ctx.body = { errorMessage: error.message, errorCode: error.code };
#     ctx.status = 400;
#   }
# })

# router.post("users.befriend", "/befriend", async(ctx) => {
#   try {
#     // This stays like this for now, but when we have multiple sessions and a remote server,
#     // the user id would be retrieved automatically.
#     if(ctx.request.body.myusername && ctx.request.body.friendusername) {
#       const user = await ctx.orm.User.findOne({where:{username:ctx.request.body.myusername}});
#       if (!user) {
#         throw Error(`No se encontró tu usuario con username ${ctx.request.body.myusername}.`);
#       }
#       const friend = await ctx.orm.User.findOne({where:{username:ctx.request.body.friendusername}});
#       if (!friend) {
#         throw Error(`No se encontró el usuario de tu amigo con username ${ctx.request.body.friendusername}.`);
#       }
#       if (user.id == friend.id) {
#         throw Error(`Ya eres amigx de ti mismx c;`);
#       }
#       let msg;
#       let friendship = await ctx.orm.Friend.findOne({
#         where: {
#           [Op.or]: [
#             { frienderid: user.id, befriendedid: friend.id },
#             { frienderid: friend.id, befriendedid: user.id }
#           ]
#         }
#       });
#       if (friendship) {
#         if (friendship.status == 'FRENS') {
#           throw Error(`Tu y ${ctx.request.body.friendusername} ya tienen una linda amistad desde antes c:`);
#         }
#         else if (friendship.frienderid == user.id) {
#           throw Error(`Ya le has enviado una solicitud de amistad a ${ctx.request.body.friendusername} anteriormente.`);
#         }
#         friendship.status = 'FRENS';
#         friendship.save();
#         msg = `¡La solicitud de amistad de ${ctx.request.body.friendusername} ha sido aceptada!`;
#       }
#       else {
#         const info = {
#           frienderid: user.id,
#           befriendedid: friend.id,
#         }
#         friendship = await ctx.orm.Friend.create(info);
#         msg = `¡Le has enviado una solicitud de amistad a ${ctx.request.body.friendusername}!`
#       }
#       ctx.body = {
#         msg: msg,
#         friendship: friendship
#       };
#       ctx.status = 201;
#     }
#     else {
#       throw Error('Se necesita entregar tu nombre de usuario como "myusername" y el de tu amigx como "friendusername".')
#     }
#   } catch(error) {
#     ctx.body = { errorMessage: error.message, errorCode: error.code };
#     ctx.status = 400;
#   }
# })

# router.post("users.unfriend", "/unfriend", async(ctx) => {
#   try {
#     // This stays like this for now, but when we have multiple sessions and a remote server,
#     // the user id would be retrieved automatically.
#     if(ctx.request.body.myusername && ctx.request.body.otherusername) {
#       const user = await ctx.orm.User.findOne({where:{username:ctx.request.body.myusername}});
#       if (!user) {
#         throw Error(`No se encontró tu usuario con username ${ctx.request.body.myusername}.`)
#       }
#       const other = await ctx.orm.User.findOne({where:{username:ctx.request.body.otherusername}});
#       if (!other) {
#         throw Error(`No se encontró el usuario del usuario con username ${ctx.request.body.otherusername}.`)
#       }
#       const friendship = await ctx.orm.Friend.findOne({
#         where: {
#           [Op.or]: [
#             {frienderid: other.id, befriendedid: user.id},
#             {frienderid: user.id, befriendedid: other.id}
#           ]
#         }
#       });
#       let msg;
#       if (!friendship) {
#         throw Error(`No hay ni solicitud ni amistad por parte del usuario ${ctx.request.body.otherusername}.`)
#       }
#       else if (friendship.status == 'FRENS') {
#         msg = `Amistad con ${ctx.request.body.otherusername} terminada.`;
#       }
#       else if (friendship.status == 'PENDING' && friendship.frienderid == user.id) {
#         msg = `Solicitud de amistad a ${ctx.request.body.otherusername} cancelada.`;
#       }
#       else {
#         msg = `Solicitud de amistad de ${ctx.request.body.otherusername} rechazada.`;
#       }
#       await friendship.destroy();
#       ctx.body = {
#         msg: msg,
#       };
#       ctx.status = 201;
#     }
#     else {
#       throw Error('Se necesita entregar tu nombre de usuario como "myusername" y el de la otra persona como "otherusername".')
#     }
#   } catch(error) {
#     ctx.body = { errorMessage: error.message, errorCode: error.code };
#     ctx.status = 400;
#   }
# })

# router.get("users.show", "/:id", async(ctx) => {
#   try {
#     // const user = await ctx.orm.User.findByPk(ctx.params.id);
#     const user = await ctx.orm.User.findOne({where:{id:ctx.params.id}});
#     ctx.body = user;
#     ctx.status = 200;
#   } catch(error) {
#     ctx.body = error;
#     ctx.status = 400;
#   }
# })

components:
  schemas:
    User:
      type: object
      properties:
        username:
          type: string
          pattern: /^[a-zA-Z0-9._\-!¡?¿$&@]+$/
        password:
          type: string
        mail:
          type: string
          # example: 'user@example.com'
        played_matches: 
          type: integer
        won_matches: 
          type: integer
        max_score: 
          type: integer
        total_score:
          type: integer
        status: 
          type: string
          enum: ['OFFLINE', 'ONLINE', 'PLAYING']  